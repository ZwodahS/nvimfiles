{
  "identifier": {
    "prefix": ["identifier"],
    "body": [
      "public function identifier(): String {",
      "\treturn ${1:this.id};",
      "}"
    ]
  },

  "ClassEmpty": {
    "prefix": ["classEmpty", "class"],
    "body": [
      "package ${1:world}",
      "",
      "class ${2:$TM_FILENAME_BASE} {",
      "}"
    ]
  },

  "ClassMessage": {
    "prefix": ["classMessage"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${2:$TM_FILENAME_BASE} extends zf.Message {",
      "\tpublic static final MessageType = \"$2\";",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic static function alloc(): ${2} {",
      "\t\tfinal m = __alloc__();",
      "\t\treturn m;",
      "\t}",
      "}"
    ],
    "description": "Snippet for empty message class."
  },
  "ClassResultMessage": {
    "prefix": ["classResultMessage"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${5:$TM_FILENAME_BASE} extends zf.Message.ResultMessage<${2:T}> {",
      "\tpublic static final MessageType = \"$5\";",
      "",
      "\t// Proxy ${3:field} to result",
      "\tpublic var $3(get, set): $2;",
      "\tinline function get_$3(): $2 {",
      "\t\treturn this.result;",
      "\t}",
      "\tpublic function set_$3(v: $2): $2 {",
      "\t\treturn this.result = v;",
      "\t}",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic static function alloc(): ${5} {",
      "\t\tfinal m = __alloc__();",
      "",
      "\t\tm.$3 = ${4:defaultValue};",
      "",
      "\t\treturn m;",
      "\t}",
      "}"
    ],
    "description": "Snippet for empty message class."
  },
  "ClassMessage.prevnext": {
    "prefix": ["classMessage.prevnext"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${2:$TM_FILENAME_BASE} extends zf.Message {",
      "\tpublic static final MessageType = \"$2\";",
      "",
      "\t@:dispose public var prev: ${3:ObjType} = ${4:null};",
      "\t@:dispose public var next: $3 = $4;",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic static function alloc(prev: $3, next: $3): ${2} {",
      "\t\tfinal m = __alloc__();",
      "",
      "\t\tm.prev = prev;",
      "\t\tm.next = next;",
      "",
      "\t\treturn m;",
      "\t}",
      "\toverride public function toString() {",
      "\t\treturn '[m:\\${this.type} \\${this.prev}->\\${this.next}]';",
      "\t}",
      "}"
    ],
    "description": "Snippet for message class with a prev and next fields."
  },
  "ClassMessage.single": {
    "prefix": ["classMessage.single"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${2:$TM_FILENAME_BASE} extends zf.Message {",
      "\tpublic static final MessageType = \"$2\";",
      "",
      "\t@:dispose public var ${3:field}: ${4:ObjectType} = ${5:null};",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic static function alloc($3: $4): ${2} {",
      "\t\tfinal m = __alloc__();",
      "",
      "\t\tm.$3 = $3;",
      "",
      "\t\treturn m;",
      "\t}",
      "}"
    ],
    "description": "Snippet for message class with a prev and next fields."
  },

  "ClassSystem": {
    "prefix": ["classSystem"],
    "body": [
      "package ${1:world}.systems;",
      "",
      "#if !macro @:build(zf.macros.Messages.build()) #end",
      "class ${2:$TM_FILENAME_BASE} extends System {",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\toverride public function init(world: zf.engine2.World) {",
      "\t\tsuper.init(world);",
      "\t\tsetupMessages(world.dispatcher);",
      "\t}",
      "}"
    ],
    "description": "Snippet for empty System class"
  },
  "system.update": {
    "prefix": ["systems.update"],
    "body": [
      "/**",
      "\tupdate loop",
      "**/",
      "override public function update(dt: Float) {",
      "\tsuper.update(dt);",
      "}",
      ""
    ],
    "description": "Snippet for the update function for System class"
  },
  "system.functions": {
    "prefix": ["systems.functions"],
    "description": "Snippet for all the functions for system class",
    "body": [
      "override public function onEvent(event: hxd.Event): Bool {",
      "\treturn false;",
      "}",
      "",
      "/**",
      "\treset the system to the same state after constructor",
      "**/",
      "override public function reset() {",
      "\tsuper.reset();",
      "}",
      "",
      "/**",
      "\tDispose the system data",
      "**/",
      "override public function dispose() {",
      "\tsuper.dispose();",
      "}",
      "",
      "/**",
      "\tupdate loop",
      "**/",
      "override public function update(dt: Float) {",
      "\tsuper.update(dt);",
      "}",
      "",
      "override public function onEntityAdded(entity: zf.engine2.Entity) {",
      "\tsuper.onEntityAdded(entity);",
      "\tfinal e: Entity = cast entity;",
      "}",
      "",
      "override public function onEntityRemoved(entity: zf.engine2.Entity) {",
      "\tsuper.onEntityRemoved(entity);",
      "\tfinal e: Entity = cast entity;",
      "}"
    ]
  },

  "ClassDataContainer": {
    "prefix": ["classDataContainer"],
    "description": [
      "Snippet for [DataContainer] object.\n",
      "\n",
      "[DataContainer] has the following characteristic.\n",
      "- Does not have a id.\n",
      "- Cannot exists outside of the parent container.\n"
    ],
    "body": [
      "/**",
      "\t${1:$TM_FILENAME_BASE} (DataContainer)",
      "**/",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "#if !macro @:build(zf.macros.Serialise.build()) #end",
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end",
      "class $1 implements Serialisable implements EntityContainer {",
      "",
      "\tfunction new() {}",
      "",
      "\t// ---- Object pooling Methods ----",
      "",
      "\tpublic function reset() {",
      "\t}",
      "",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\treturn object;",
      "\t}",
      "",
      "\tpublic static function empty(): $1 {",
      "\t\treturn alloc();",
      "\t}",
      "}"
    ]
  },

  "ClassData": {
    "prefix": ["classData"],
    "description": [
      "Snippet for [Data] object.\n",
      "\n",
      "Essentially, this is a object pool-ed object.\n",
      "This is not meant to be serialised."
    ],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} implements Disposable {",
      "",
      "\tfunction new() {}",
      "",
      "\t// ---- Object pooling Methods ----",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ]
  },

  "ClassEntity": {
    "prefix": ["classEntity"],
    "body": [
      "package ${2:world}.rules.entities;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Entity {",
      "",
      "\t@:dispose var _proxy: ${1:$TM_FILENAME_BASE}Proxy;",
      "",
      "\tpublic var proxy(get, never): $1Proxy;",
      "",
      "\tpublic function get_proxy(): $1Proxy {",
      "\t\tif (this._proxy != null || this.world == null) return this._proxy;",
      "\t\tthis._proxy = $1Proxy.alloc(this.world, this);",
      "\t\treturn this._proxy;",
      "\t}",
      "",
      "\t@:dispose(\"set\") public var logic: $1LogicComponent = null;",
      "",
      "\t@:dispose(\"set\") public var render: $1RenderComponent = null;",
      "",
      "\t@:dispose(\"set\") public var state: $1StateComponent = null;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\tpublic static function alloc(id: Int, factory: $1Factory): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.kind = EntityKind.$1;",
      "\t\tobject.factory = factory;",
      "\t\tobject.id = id;",
      "",
      "\t\tobject.logic = $1LogicComponent.alloc(factory);",
      "\t\tobject.render = $1RenderComponent.alloc(factory);",
      "\t\tobject.state = $1StateComponent.alloc(factory);",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ],
    "description": "Create engine2.Entity from template"
  },
  "ClassEntityFactory.NoConf": {
    "prefix": ["classEntityFactory.noConf"],
    "body": [
      "package ${4:world}.rules.factories;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends EntityFactory {",
      "",
      "\tpublic function new(rules: Rules) {",
      "\t\tsuper(\"${2:id}\", rules);",
      "\t}",
      "",
      "\t// ---- Make / Save / Load ---- //",
      "\toverride public function make(id: Int, worldState: WorldState, conf: Dynamic = null): ${3:Entity} {",
      "\t\tfinal entity = $3.alloc(id, this);",
      "\t\treturn entity;",
      "\t}",
      "}"
    ],
    "description": "Create a engine2.EntityFactory from template"
  },
  "ClassEntityFactory": {
    "prefix": ["classEntityFactory"],
    "body": [
      "package ${3:world}.rules.factories;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends EntityFactory {",
      "\tpublic var conf: ${2:E}Conf;",
      "",
      "\tpublic function new(rules: Rules, conf: $2Conf) {",
      "\t\tsuper(conf.id, rules);",
      "\t\tthis.conf = conf;",
      "\t}",
      "",
      "\t// ---- Make / Save / Load ---- //",
      "\toverride public function make(id: Int, worldState: WorldState, conf: Dynamic = null): $2 {",
      "\t\tfinal entity = $2.alloc(id, this);",
      "\t\treturn entity;",
      "\t}",
      "}"
    ],
    "description": "Create a engine2.EntityFactory from template"
  },
  "ClassEntityConf": {
    "prefix": ["classConf"],
    "body": [
      "package ${2:world}.rules.confs;",
      "",
      "typedef ${1:$TM_FILENAME_BASE} = {",
      "\tpublic var id: String;",
      "\tpublic var stringId: String;",
      "\tpublic var assetId: String;",
      "}"
    ]
  },

  "ClassProxy": {
    "prefix": ["classProxy"],
    "body": [
      "package ${4:world}.rules.proxies;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Proxy implements Disposable {",
      "",
      "\t@:dispose var ${3:object}: ${2:Object} = null;",
      "",
      "\tfunction new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\tpublic static function alloc(world: World, $3: $2): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.world = world;",
      "\t\tobject.$3 = $3;",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ]
  },

  "ClassComponent": {
    "prefix": ["classStateComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "#if !macro @:build(zf.macros.Serialise.build()) #end",
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Component implements Serialisable implements EntityContainer {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\t@:dispose public var factory(default, set): ${2:Entity}Factory = null;",
      "",
      "\tpublic function set_factory(v: $2Factory): $2Factory {",
      "\t\tthis.factory = v;",
      "\t\tonFactorySet();",
      "\t\treturn this.factory;",
      "\t}",
      "",
      "\tpublic var ${3:entity}(get, never): $2;",
      "",
      "\tinline public function get_$3(): $2 {",
      "\t\treturn cast this.entity;",
      "\t}",
      "",
      "\tfunction new() {}",
      "",
      "\t/**",
      "\t\tInitialise the state component for the specific card typeId, if any",
      "\t**/",
      "\tfunction onFactorySet() {}",
      "",
      "\t// ---- Object pooling Methods ----",
      "\tpublic static function alloc(factory: $2Factory): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.factory = factory;",
      "",
      "\t\treturn object;",
      "\t}",
      "",
      "\tpublic static function empty(): $1 {",
      "\t\treturn alloc(null);",
      "\t}",
      "",
      "}"
    ],
    "description": "Create a component class from template"
  },
  "ClassComponentNoSerialise": {
    "prefix": ["classComponent", "classLogicComponent", "classRenderComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Component {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\t@:dispose public var factory(default, set): ${2:Entity}Factory = null;",
      "",
      "\tpublic function set_factory(v: $2Factory): $2Factory {",
      "\t\tthis.factory = v;",
      "\t\tonFactorySet();",
      "\t\treturn this.factory;",
      "\t}",
      "",
      "\tpublic var ${3:entity}(get, never): $2;",
      "",
      "\tinline public function get_$3(): $2 {",
      "\t\treturn cast this.entity;",
      "\t}",
      "",
      "\tfunction new() {}",
      "",
      "\tfunction onFactorySet() {}",
      "",
      "\tpublic static function alloc(factory: $2Factory): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.factory = factory;",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ],
    "description": "Create a component class from template"
  },
  "ClassDataComponent": {
    "prefix": ["classDataComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "#if !macro @:build(zf.macros.Serialise.build()) #end",
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Component implements Serialisable implements EntityContainer {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\tfunction new() {}",
      "",
      "\t// ---- Object pooling Methods ----",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "\t\treturn object;",
      "\t}",
      "",
      "\tpublic static function empty(): $1 {",
      "\t\treturn alloc();",
      "\t}",
      "",
      "}"
    ],
    "description": "Snippet for Data-type Component."
  },

  "ClassContext": {
    "prefix": ["classContext"],
    "body": [
      "package ${2:world}.rules.contexts;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Context {",
      "",
      "\t@:dispose var ${4:object}: ${3:Object} = null;",
      "",
      "\tfunction new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\tpublic static function alloc(world: World, $4: $3): $1 {",
      "\t\tfinal ctx = $1.__alloc__();",
      "",
      "\t\tctx.world = world;",
      "\t\tctx.$4 = $4;",
      "",
      "\t\treturn ctx;",
      "\t}",
      "}"
    ]
  },
  "ClassRule": {
    "prefix": ["classRule"],
    "description": [
      "Snippet for [RuleObject] object.\n",
      "\n",
      "[RuleObject] has the following characteristic.\n",
      "- Singleton, loaded to Rules.",
      "\n",
      "Related Snippet\n",
      "- rules.loadRule\n",
      "\n"
    ],
    "body": [
      "package ${2:world}.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\tpublic var id: String;",
      "}",
      "",
      "/**",
      "\t$1 (RuleObject)",
      "**/",
      "#if !macro @:build(zf.macros.ClassBuilder.build()) #end",
      "class $1 implements Identifiable {",
      "\t@:forward var conf: $1Conf;",
      "",
      "\tpublic function identifier(): String {",
      "\t\treturn this.conf.id;",
      "\t}",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tthis.conf = conf;",
      "\t}",
      "}"
    ]
  },
  "varComponent": {
    "prefix": ["varcomponent"],
    "body": [
      "@:dispose(\"set\") public var ${1:component}: ${2:Component} = null;"
    ]
  },
  "varComponent.full": {
    "prefix": ["varcomponent.full"],
    "body": [
      "@:dispose(\"set\") public var ${1:component}(default, set): ${2:Component} = null;",
      "",
      "public function set_$1(component: $2): $2 {",
      "\tfinal prev = this.$1;",
      "\tthis.$1 = component;",
      "\tonComponentChanged(prev, this.$1);",
      "\treturn this.$1;",
      "}"
    ]
  },

  "collectEntities": {
    "prefix": ["collectEntities"],
    "body": [
      "public function collectEntities(entities: Entities<Entity>) {",
      "}"
    ]
  },
  "collectEntities.Macro": {
    "prefix": ["macro.collectEntities"],
    "body": [
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end"
    ]
  },
  "collectEntities.@collectEntity": {
    "description": [
      "Collect all entities under this field.\n",
      "If field is an entity, or an array of entities, they will be collected.\n",
      "If field is an EntityContainer, than it will call the collectEntities method.\n"
    ],
    "prefix": ["@collectEntity", "@ce"],
    "body": ["@collectEntity "]
  },

  "ClassLogicObject": {
    "prefix": ["classLogicObject"],
    "description": [
      "Create a dynamic rule\n",
      "Dynamic Rules are rule object that has a state.\n",
      "Logic object also has a factory.\n",
      "\n",
      "Related Snippet\n",
      "- classLogicObjectFactory\n",
      "- classProxy\n",
      "- classContext\n",
      "- classConf\n",
      "- rules.loadLogicObjectn\n",
      "\n"
    ],
    "body": [
      "package ${2:world}.rules;",
      "",
      "/**",
      "\t${1:$TM_FILENAME_BASE} (LogicObject)",
      "**/",
      "#if !macro @:build(zf.macros.ClassBuilder.build()) #end",
      "#if !macro @:build(zf.macros.Serialise.build()) #end",
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class $1 implements Serialisable {",
      "",
      "\t@:dispose var factory: $1Factory = null;",
      "",
      "\t@:forward @:dispose var conf: $1Conf = null;",
      "",
      "\tfunction new() {}",
      "",
      "\tpublic static function empty() {",
      "\t\treturn alloc(null);",
      "\t}",
      "",
      "\tpublic static function alloc(factory: $1Factory): CardAbility {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.factory = factory;",
      "",
      "\t\treturn object;",
      "\t}",
      "",
      "\tpublic function loadStruct(context: SerialiseContext, data: Dynamic): CardAbility {",
      "\t\tfinal rules: Rules = cast context.get(\"Rules\");",
      "\t\tfinal id: String = data.id;",
      "\t\tfinal factory: $1Factory = rules.${3:dynamicRules}.get(id);",
      "",
      "\t\tthis.factory = factory;",
      "",
      "\t\t__loadStruct__(context, data);",
      "",
      "\t\treturn this;",
      "\t}",
      "}"
    ]
  },
  "ClassLogicObjectFactory": {
    "prefix": ["classLogicObjectFactory"],
    "description": [
    ],
    "body": [
      "package ${3:world}.rules.factories;",
      "",
      "#if !macro @:build(zf.macros.ClassBuilder.build()) #end",
      "class ${1:$TM_FILENAME_BASE} {",
      "",
      "\tpublic var conf: ${2:Rule}Conf;",
      "",
      "\tpublic var rules: Rules;",
      "",
      "\tpublic function new(rules: Rules, conf: $2Conf) {",
      "\t\tthis.rules = rules;",
      "\t\tthis.conf = conf;",
      "\t}",
      "",
      "\tpublic function make(conf: Dynamic): CardAbility {",
      "\t\tfinal rule =  $2.alloc(this);",
      "\t\treturn rule;",
      "\t}",
      "}"
    ]
  },

  "ClassState": {
    "prefix": ["classState"],
    "body": [
      "package ${2:world}.states;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends zf.sm.State {",
      "\tpublic static final Wait: String = \"$1.Wait\";",
      "",
      "\tpublic var world(default, null): World;",
      "",
      "\tpublic var dispatcher(get, never): MessageDispatcher;",
      "",
      "\tinline public function get_dispatcher(): MessageDispatcher {",
      "\t  return this.world.dispatcher;",
      "\t}",
      "",
      "\tpublic function new(name: String) {",
      "\t\tsuper(name);",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tthis.world = null;",
      "\t}",
      "",
      "\toverride public function clone(): $1 {",
      "\t\treturn new $1(this.name);",
      "\t}",
      "",
      "\tpublic static function registerStates(stateManager: zf.sm.StateManager, world: World) {",
      "\t\tstateManager.registerState(new zf.sm.Wait($1.Wait));",
      "\t}",
      "}"
    ]
  },
  "ClassChildState": {
    "prefix": ["classChildState"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:Name}State extends $TM_FILENAME_BASE {",
      "",
      "\tfunction new() {",
      "\t\tsuper($TM_FILENAME_BASE.$1);",
      "\t}",
      "",
      "\toverride public function clone(): $1State {",
      "\t\treturn $1State.alloc(this.world);",
      "\t}",
      "",
      "\tpublic static function alloc(world: World): $1State {",
      "\t\tfinal state = $1State.__alloc__();",
      "",
      "\t\tstate.world = world;",
      "",
      "\t\treturn state;",
      "\t}",
      "}"
    ]
  },
  "state.update": {
    "prefix": ["state.update"],
    "body": [
      "override public function update(dt: Float) {",
      "\t$0",
      "}"
    ]
  },
  "state.getNextState": {
    "prefix": ["state.getNextState"],
    "body": [
      "override public function getNextState(): zf.sm.State {",
      "\t$0",
      "\treturn null;",
      "}"
    ]
  },
  "state.onStateEnterExit": {
    "prefix": ["state.onStateEnterExit"],
    "body": [
      "override public function onStateEnter() {}",
      "override public function onStateExit() {}"
    ]
  },

  "varsingleton": {
    "prefix": ["varsingleton"],
    "body": [
      "var _${1:item}: ${2:ItemType};",
      "public var $1(get, never): $2;",
      "",
      "public function get_$1(): $2 {",
      "\tif (this._$1 == null) this._$1 = new $2(${3:});",
      "\treturn this._$1;",
      "}"
    ]
  },

  "varproxy": {
    "prefix": ["varproxy"],
    "body": [
      "@:dispose var _${1:proxy}: ${2:$TM_FILENAME_BASE}Proxy;",
      "public var $1(get, never): $2Proxy;",
      "",
      "public function get_$1(): $2Proxy {",
      "\tif (this._$1 == null) this._$1 = $2Proxy.alloc(this.world, this);",
      "\treturn this._$1;",
      "}"
    ]
  },

  "dispatcher.listen.old": {
    "prefix": ["mListen", "dispatcher.listen"],
    "body": [
      "${3:dispatcher}.listen($1.MessageType, (message: zf.Message) -> {",
      "\thandle$1(cast message);",
      "}, $2);"
    ],
    "description": ""
  },
  "messagesHandle.old": {
    "prefix": ["mHandle.old"],
    "body": [
      "function handle${1:Message}(m: $1) {",
      "\t//note: message will be dispose once this function exits.",
      "}"
    ]
  },
  "messagesHandle": {
    "prefix": ["handleMessage", "mHandle"],
    "body": [
      "@:handleMessage(\"${1:Message}\", ${2:0})",
      "function m${3:handleMessage}(m: $1) {",
      "\t${4://note: message will be dispose once this function exits.}",
      "}"
    ]
  },

  "DispatcherDispatch": {
    "prefix": ["dispatch"],
    "body": [
      "${3:this.}dispatcher.dispatch(${1:Message}.alloc($2))${4:.dispose()};"
    ]
  },
  "DispatchAndGetResult": {
    "prefix": ["mGetResult"],
    "body": [
      "final ${2:value} = ${4:this.}dispatcher.getResult(${1:Message}.alloc($3));"
    ]
  },
  "mDispatcherDispatch": {
    "prefix": ["mDispatch"],
    "body": [
      "final m = ${4:this.}dispatcher.dispatch(${1:Message}.alloc($2));",
      "m.dispose();"
    ]
  },
  "messages.Macro": {
    "prefix": ["macro.messages"],
    "body": [
      "#if !macro @:build(zf.macros.Messages.build()) #end"
    ]
  },

  "ClassUIElement": {
    "prefix": ["classUIElement"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} extends UIElement implements Disposable {",
      "",
      "\tpublic var display: h2d.Object;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "",
      "\t\tinitCommon();",
      "\t}",
      "",
      "\tfunction initCommon() {",
      "\t\tthis.addChild(this.display = new h2d.Object());",
      "\t}",
      "",
      "\t/**",
      "\t\tReset the UIElement to a default state",
      "\t**/",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t\t// reset only the non-common object to make object pooling better",
      "\t}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.render();",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ],
    "description": "Create a empty UIElement"
  },

  "ClassUIElement.noPool": {
    "prefix": ["classUIElement.noPool"],
    "body": [
      "class ${1:$TM_FILENAME_BASE} extends UIElement {",
      "",
      "\tpublic var display: h2d.Object;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "",
      "\t\tinitCommon();",
      "\t}",
      "",
      "\tfunction initCommon() {",
      "\t\tthis.addChild(this.display = new h2d.Object());",
      "\t}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "}"
    ],
    "description": "Create a empty UIElement"
  },
  "ClassUIElementScreen": {
    "prefix": ["classUIElement.screen"],
    "body": [
      "package ${1:world}.ui;",
      "",
      "#if !macro @:build(zf.macros.Messages.build()) #end",
      "class $TM_FILENAME_BASE extends UIElement {",
      "",
      "\tpublic var display: h2d.Object;",
      "",
      "\tpublic var world: World;",
      "",
      "\tpublic var dispatcher(default, null): MessageListenersGroup;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "\t\tthis.addChild(this.display = new h2d.Object());",
      "\t}",
      "",
      "\tpublic function init(world: World) {",
      "\t\tthis.world = world;",
      "\t\tthis.dispatcher = new MessageListenersGroup(this.world.dispatcher);",
      "\t\tsetupMessages(this.dispatcher);",
      "\t}",
      "",
      "\tpublic function enter() {",
      "\t\tthis.display.visible = true;",
      "\t\tthis.dispatcher.enable();",
      "\t}",
      "",
      "\tpublic function exit() {",
      "\t\tthis.display.visible = false;",
      "\t\tthis.dispatcher.disable();",
      "\t}",
      "}"
    ]
  },


  "DynamicTypeClassDefinition": {
    "prefix": ["classDynamicType"],
    "body": [
      "package world.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\tpublic var id: String;",
      "\tpublic var name: String;",
      "\tpublic var assetId: String;",
      "}",
      "",
      "/**",
      "\tDefine a type that is dynamically loaded from file",
      "**/",
      "#if !macro @:build(zf.macros.ClassBuilder.build()) #end",
      "class $1 implements Identifiable {",
      "\t",
      "\tpublic static final types: Dynamic = {};",
      "\t",
      "\t@:forward var conf: $1Conf;",
      "",
      "\tpublic function identifier(): String {",
      "\treturn this.id;",
      "\t}",
      "",
      "\tpublic var displayName(get, never): String;",
      "",
      "\tpublic function get_displayName(): String {",
      "\t\treturn S.get('.${assetId}');",
      "\t}",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tthis.conf = conf;",
      "\t}",
      "}"
    ],
    "description": "Create a dynamic type"
  },






  "Rules.loadDynamicType": {
    "prefix": ["rules.loadDynamicTypes"],
    "body": [
      "/**",
      "\tThis loads into both Rules.${1:Type} as Dynamic and Rules.${2:types} as Map",
      "",
      "\tconfig.hs will requires the conf to be stored as $2.",
      "**/",
      "public final $2: Map<String, $1> = [];",
      "function load$1(dir: String, filePath: String) {",
      "\tfinal t: DynamicAccess<Dynamic> = $1.types;",
      "\tfunction add(type: $1) {",
      "\t\tthis.$2[type.id] = type;",
      "\t\tt.set(type.name, type);",
      "\t\tLogger.debug('$1 Loaded: \\${type.name}.', '[Rules]');",
      "\t}",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1.$1Conf = t;",
      "\t\tfinal tt = new $1(conf);",
      "\t\tadd(tt);",
      "\t}",
      "}"
    ]
  },
  "Rules.loadEntity": {
    "prefix": ["rules.loadEntity"],
    "body": [
      "/**",
      "\tThis loads factories for ${1:Entity}.",
      "**/",
      "function load$1(dir: String, filePath: String) {",
      "\tfinal factories: Array<$1Factory> = [];",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal confs: Array<Dynamic> = executePath(configPath);",
      "",
      "\tfor (c in confs) {",
      "\t\tfinal conf: $1Conf = c;",
      "\t\tfinal factory = new $1Factory(this, conf);",
      "\t\tfactories.push(factory);",
      "\t}",
      "",
      "\tfor (factory in factories) registerEntity(factory);",
      "\tLogger.debug('\\${factories.length} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },
  "Rules.loadRule": {
    "prefix": ["rules.loadRule"],
    "body": [
      "/**",
      "\tThis load the ${1:RuleObject} to ${2:ruleObjects}",
      "**/",
      "public var $2: Map<String, $1> = [];",
      "function load$1(dir: String, filePath: String) {",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tvar count = 0;",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1.$1Conf = t;",
      "\t\tfinal ${3:rule} = new $1(conf);",
      "\t\tthis.$2.set($3.id, $3);",
      "\t\tcount += 1;",
      "\t}",
      "\tLogger.debug('\\${count} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },
  "Rules.loadLogicObject": {
    "prefix": ["rules.loadLogicObject"],
    "description": [
      "Snippet for [LogicObject].\n",
      "",
      "- Similar to Rule, specify logic and is reference by typeId.\n",
      "- Similar to DataContainer, cannot exists outside of the parent container.\n",
      "- Similar to Entity, provide logic.\n"
    ],
    "body": [
      "/**",
      "\tThis load the ${1:LogicObject}Factory to ${2:logicObjects}",
      "**/",
      "public var $2: Map<String, $1Factory> = [];",
      "function load$1(dir: String, filePath: String) {",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tvar count = 0;",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1Conf = t;",
      "\t\tfinal object = new $1Factory(this, conf);",
      "\t\tthis.$2.set(object.id, object);",
      "\t\tcount += 1;",
      "\t}",
      "\tLogger.debug('\\${count} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },




  "EnumAbstract": {
    "prefix": ["enumabstract"],
    "body": [
      "enum abstract ${1:$TM_FILENAME_BASE}(${2:String}) from $2 to $2 {",
      "}"
    ]
  },

  "TestWithoutWorld": {
    "prefix": ["classTestCase"],
    "body": [
      "package tests;",
      "",
      "/**",
      "\tA template for test cases without World object",
      "**/",
      "class ${1:$TM_FILENAME_BASE} extends TestCase {",
      "\tpublic static final Name = \"template\";",
      "",
      "\tpublic function new(testId: String) {",
      "\t\tsuper(testId, Name);",
      "\t}",
      "",
      "\toverride function setup() {",
      "\t\tsuper.setup();",
      "\t\tinitSteps();",
      "\t}",
      "",
      "\tfunction initSteps() {",
      "\t\trun(() -> {",
      "\t\t});",
      "\t}",
      "}"
    ],
    "description": "Test Template Without World"
  },
  "TestWithWorld": {
    "prefix": ["classWorldTestCase"],
    "body": [
      "package tests;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends WorldTestCase {",
      "\tpublic static final Name = \"$1\";",
      "",
      "\tpublic function new(testId: String) {",
      "\t\tsuper(testId, Name);",
      "\t}",
      "",
      "\toverride function setup() {",
      "\t\tsuper.setup();",
      "\t\tinitSteps();",
      "\t}",
      "",
      "\tfunction initSteps() {",
      "\t\trun(() -> {",
      "\t\t});",
      "\t}",
      "}"
    ],
    "description": "Test Template Without World"
  },
  "run": {
    "prefix": ["run"],
    "body": [
      "run(() -> {",
      "\tfinal state = this.world.worldState;",
      "\t${1}",
      "});"
    ],
    "description": "run with a state for test case"
  },

  "uiComponent": {
    "prefix": ["classUIComponent"],
    "body": [
      "class ${1:$TM_FILENAME_BASE}Component extends zf.ui.builder.Component {",
      "\tpublic function new() {",
      "\t\tsuper(\"${2:}\");",
      "\t}",
      "",
      "\toverride public function makeFromStruct(s: Dynamic, context: BuilderContext): h2d.Object {",
      "\t\treturn make(zf.Access.struct(s), context);",
      "\t}",
      "",
      "\toverride public function makeFromXML(element: Xml, context: BuilderContext): h2d.Object {",
      "\t\treturn make(zf.Access.xml(element), context);",
      "\t}",
      "",
      "\tfunction make(conf: zf.Access, context: BuilderContext): h2d.Object {",
      "\t\tfinal component = new $1();",
      "\t\treturn component;",
      "\t}",
      "}"
    ]
  },
  "zfEffect": {
    "prefix": ["classEffect"],
    "body": [
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\t> Effect.EffectConf,",
      "}",
      "",
      "class $1 extends Effect {",
      "",
      "\tvar object: h2d.Object;",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tsuper(conf);",
      "\t\tthis.conf = conf;",
      "\t\tdefaultConf(conf);",
      "\t\treset();",
      "\t}",
      "",
      "\tfunction defaultConf(conf: $1Conf) { }",
      "",
      "\toverride function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\toverride public function copy(): $1 {",
      "\t\treturn new $1(this.conf);",
      "\t}",
      "",
      "\toverride public function applyTo(object: h2d.Object, copy: Bool = false): Effect {",
      "\t\tfinal e = super.applyTo(object, copy);",
      "\t\tif (copy == true) return e;",
      "",
      "\t\tthis.object = object;",
      "\t\treturn this;",
      "\t}",
      "}"
    ]
  },

  "Serialisable": {
    "prefix": ["serialise"],
    "body": [
      "/**",
      "\tConvert to struct",
      "\t@return the struct representing the object",
      "**/",
      "public function toStruct(context: SerialiseContext): Dynamic {",
      "\tfinal sf: ${1:$TM_FILENAME_BASE}SF = {};",
      "\treturn sf;",
      "}",
      "",
      "/**",
      "\tLoad from struct.",
      "\t@return the object itself to allow for chaining",
      "**/",
      "public function loadStruct(context: SerialiseContext, data: Dynamic): $1 {",
      "\tfinal sf: ${1}SF = data;",
      "\treturn this;",
      "}"
    ]
  },
  "Serialisable.Macro": {
    "prefix": ["macro.serialise"],
    "body": [
      "#if !macro @:build(zf.macros.Serialise.build()) #end"
    ]
  },
  "Serialisable.SaveLoad": {
    "prefix": ["serialisable.saveload"],
    "body": [
      "// ---- Save / Load ----",
      "",
      "public function toStruct(context: SerialiseContext): Dynamic {",
      "\tfinal struct = __toStruct__(context, {});",
      "\treturn struct;",
      "}",
      "",
      "public function loadStruct(context: SerialiseContext, sf: Dynamic): ${1:$TM_FILENAME_BASE} {",
      "\t__loadStruct__(context, sf);",
      "\treturn this;",
      "}"
    ]
  },
  "Serialisable.@:serialise": {
    "prefix": ["@:serialise"],
    "description": [
      "serialise the field.\n",
      "\n",
      "@:serialise(key: [null], fromContext: [false])\n",
      "key - the store key. if null will use the field name\n",
      "fromContext - if true will get the object from context instead of serialising it.\n",
      "e.g. @:serialise(null, true) to store the id + take the object from context.\n",
      "\n",
      "See @:fromContext to always serialise from context without saving."
    ],
    "body": ["@:serialise "]
  },
  "Serialisable.@:fromContext": {
    "prefix": ["@:fromContext"],
    "description": [
      "always take the value of this field from context on load based on the identifier."
    ],
    "body": ["@:fromContext "]
  },

  "ObjectPool.Macro": {
    "prefix": ["macro.objectPool"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end"
    ]
  },
  "ObjectPool.dispose": {
    "prefix": ["@:dispose"],
    "description": [
      "@:dispose(type: [all])\n",
      "\n",
      "@:dispose(\"all\")\n",
      "@:dispose(\"set\", value: [null])\n",
      "@:dispose(\"func\", funcName)\n",
      "\n",
      "All|Auto\n",
      "- for primitive, it will set to the default value.",
      "- for disposable, dispose() will be called.",
      "- for array, it will set to the default value.",
      "-"
    ],
    "body": ["@:dispose "]
  },

  "objectPoolalloc": {
    "prefix": ["objectPool.alloc"],
    "body": [
      "public static function ${2:alloc}(): ${1:$TM_FILENAME_BASE} {",
      "\tfinal object = $1.__alloc__();",
      "\treturn object;",
      "}"
    ]
  },

  "ClassBuilder.Macro": {
    "prefix": ["macro.classBuilder", "classBuilder"],
    "body": [
      "#if !macro @:build(zf.macros.ClassBuilder.build()) #end"
    ]
  },
  "ClassBuilder.@:forward": {
    "prefix": ["@:forward"],
    "body": [
      "@:forward "
    ],
    "description": [
      "@:forward(fields: null)\n",
      "\n",
      "If fields is not provided, then all fields will be forwarded if it does not\n",
      "exists in the containing class."
    ]
  },

  "tooltipHelperSet": {
    "prefix": ["tooltipHelperSet"],
    "body": [
      "final window = new TooltipWindow();",
      "${1:object}.tooltipHelper = ${2:this.tooltipHelper};",
      "$1.tooltipWindow = window;",
      "$1.tooltipShowConf = { preferredDirection: [Right, Left, Up, Down] };"
    ]
  },
  "XmlComponent": {
    "prefix": ["classXmlComponent"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end",
      "class ${1:$TM_FILENAME_BASE} extends zf.ui.builder.XmlComponent {",
      "",
      "\tpublic function new() {",
      "\t\tsuper(\"ui/components/$1.xml\");",
      "",
      "\t\tinitComponent();",
      "\t}",
      "",
      "\t/**",
      "\t\tReset the UIElement to a default state",
      "\t**/",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.render();",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ]
  },

  "init": {
    "prefix": ["init"],
    "body": [
      "public function init(world: zf.engine2.World) {",
      "\t${1:}",
      "}"
    ]
  },

  "assert": {
    "prefix": ["assert"],
    "body": [
      "Assert.assert($0);"
    ]
  }
}
