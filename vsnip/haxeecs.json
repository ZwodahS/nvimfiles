{
  "identifier": {
    "prefix": ["identifier"],
    "body": [
      "public function identifier(): String {",
      "\treturn ${1:this.id};",
      "}"
    ]
  },

  "ClassEmpty": {
    "prefix": ["classEmpty", "class"],
    "body": [
      "package ${1:world}",
      "",
      "class ${2:$TM_FILENAME_BASE} {",
      "}"
    ]
  },

  "ClassMessage": {
    "prefix": ["classMessage"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${2:$TM_FILENAME_BASE} extends zf.Message {",
      "\tpublic static final MessageType = \"$2\";",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic function reset() {}",
      "",
      "\tpublic static function alloc(): ${2} {",
      "\t\tfinal m = __alloc__();",
      "\t\treturn m;",
      "\t}",
      "}"
    ],
    "description": "Create a message class from template."
  },
  "ClassMessage.prevnext": {
    "prefix": ["classMessage.prevnext"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${2:$TM_FILENAME_BASE} extends zf.Message {",
      "\tpublic static final MessageType = \"$2\";",
      "",
      "\tpublic var prev: ${3:ObjType} = null;",
      "\tpublic var next: $3 = null;",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tthis.prev = null;",
      "\t\tthis.next = null;",
      "\t}",
      "",
      "\tpublic static function alloc(prev: $3, next: $3): ${2} {",
      "\t\tfinal m = __alloc__();",
      "",
      "\t\tm.prev = prev;",
      "\t\tm.next = next;",
      "",
      "\t\treturn m;",
      "\t}",
      "\toverride public function toString() {",
      "\t\treturn '[m:\\${this.type} \\${this.prev}->\\${this.next}]';",
      "\t}",
      "}"
    ],
    "description": "Create a message class from template."
  },

  "ClassSystem": {
    "prefix": ["classSystem"],
    "body": [
      "package ${1:world}.systems;",
      "",
      "#if !macro @:build(zf.macros.Messages.build()) #end",
      "class ${2:$TM_FILENAME_BASE} extends System {",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\toverride public function init(world: zf.engine2.World) {",
      "\t\tsuper.init(world);",
      "\t\tsetupMessages(world.dispatcher);",
      "\t}",
      "}"
    ],
    "description": "Create a system class from template."
  },
  "system.update": {
    "prefix": ["systems.update"],
    "body": [
      "/**",
      "\tupdate loop",
      "**/",
      "override public function update(dt: Float) {",
      "\tsuper.update(dt);",
      "}",
      ""
    ]
  },
  "system.functions": {
    "prefix": ["systems.functions"],
    "body": [
      "override public function onEvent(event: hxd.Event): Bool {",
      "\treturn false;",
      "}",
      "",
      "/**",
      "\treset the system to the same state after constructor",
      "**/",
      "override public function reset() {",
      "\tsuper.reset();",
      "}",
      "",
      "/**",
      "\tDispose the system data",
      "**/",
      "override public function dispose() {",
      "\tsuper.dispose();",
      "}",
      "",
      "/**",
      "\tupdate loop",
      "**/",
      "override public function update(dt: Float) {",
      "\tsuper.update(dt);",
      "}",
      "",
      "override public function onEntityAdded(entity: zf.engine2.Entity) {",
      "\tsuper.onEntityAdded(entity);",
      "\tfinal e: Entity = cast entity;",
      "}",
      "",
      "override public function onEntityRemoved(entity: zf.engine2.Entity) {",
      "\tsuper.onEntityRemoved(entity);",
      "\tfinal e: Entity = cast entity;",
      "}"
    ]
  },

  "ClassDataContainer": {
    "prefix": ["classDataContainer"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "#if !macro @:build(zf.macros.Serialise.build()) #end",
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end",
      "class ${1:$TM_FILENAME_BASE} implements Serialisable implements EntityContainer {",
      "",
      "\tfunction new() {}",
      "",
	    "\t// ---- Object pooling Methods ----",
      "",
      "\tpublic function reset() {",
      "\t}",
      "",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\treturn object;",
      "\t}",
      "",
      "\tpublic static function empty(): $1 {",
      "\t\treturn alloc();",
      "\t}",
      "}"
    ]
  },
  "ClassComponent": {
    "prefix": ["classStateComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "#if !macro @:build(zf.macros.Serialise.build()) #end",
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Component implements Serialisable implements EntityContainer {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\tpublic var factory(default, set): ${2:Entity}Factory;",
      "",
      "\tpublic function set_factory(v: $2Factory): $2Factory {",
      "\t\tthis.factory = v;",
      "\t\tonFactorySet();",
      "\t\treturn this.factory;",
      "\t}",
      "",
      "\tpublic var ${3:entity}(get, never): $2;",
      "",
      "\tinline public function get_$3(): $2 {",
      "\t\treturn cast this.entity;",
      "\t}",
      "",
      "\tfunction new() {}",
      "",
      "\t/**",
      "\t\tInitialise the state component for the specific card typeId, if any",
      "\t**/",
      "\tfunction onFactorySet() {}",
      "",
	    "\t// ---- Object pooling Methods ----",
      "",
      "\toverride public function dispose() {",
      "\t\tsuper.dispose();",
      "\t\t__dispose__();",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tthis.factory = null;",
      "\t}",
      "",
      "\tpublic static function alloc(factory: $2Factory): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.factory = factory;",
      "",
      "\t\treturn object;",
      "\t}",
      "",
      "\t// This is rarely called since entity always creates these component.",
      "\tpublic static function empty(): $1 {",
      "\t\treturn alloc(null);",
      "\t}",
      "",
      "}"
    ],
    "description": "Create a component class from template"
  },
  "ClassComponentNoSerialise": {
    "prefix": ["classComponent", "classLogicComponent", "classRenderComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Component {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\tpublic var factory(default, set): ${2:Entity}Factory;",
      "",
      "\tpublic function set_factory(v: $2Factory): $2Factory {",
      "\t\tthis.factory = v;",
      "\t\tonFactorySet();",
      "\t\treturn this.factory;",
      "\t}",
      "",
      "\tpublic var ${3:entity}(get, never): $2;",
      "",
      "\tinline public function get_$3(): $2 {",
      "\t\treturn cast this.entity;",
      "\t}",
      "",
      "\tfunction new() {}",
      "",
      "\tfunction onFactorySet() {}",
      "",
	    "\t// ---- Object pooling Methods ----",
      "",
      "\toverride public function dispose() {",
      "\t\tsuper.dispose();",
      "\t\t__dispose__();",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tthis.factory = null;",
      "\t}",
      "",
      "\tpublic static function alloc(factory: $2Factory): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.factory = factory;",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ],
    "description": "Create a component class from template"
  },

  "ClassEntity": {
    "prefix": ["classEntity"],
    "body": [
      "package ${2:world}.rules.entities;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Entity {",
      "",
      "\tvar _proxy: ${1:$TM_FILENAME_BASE}Proxy = null;",
      "",
      "\tpublic var proxy(get, never): $1Proxy;",
      "",
      "\tpublic function get_proxy(): $1Proxy {",
      "\t\tif (this._proxy != null || this.world == null) return this._proxy;",
      "\t\tthis._proxy = $1Proxy.alloc(this.world, this);",
      "\t\treturn this._proxy;",
      "\t}",
      "",
      "\tpublic var logic(default, set): $1LogicComponent = null;",
      "",
      "\tpublic function set_logic(component: $1LogicComponent): $1LogicComponent {",
      "\t\tfinal prev = this.logic;",
      "\t\tthis.logic = component;",
      "\t\tonComponentChanged(prev, this.logic);",
      "\t\treturn this.logic;",
      "\t}",
      "",
      "\tpublic var render(default, set): $1RenderComponent = null;",
      "",
      "\tpublic function set_render(component: $1RenderComponent): $1RenderComponent {",
      "\t\tfinal prev = this.render;",
      "\t\tthis.render = component;",
      "\t\tonComponentChanged(prev, this.render);",
      "\t\treturn this.render;",
      "\t}",
      "",
      "\tpublic var state(default, set): $1StateComponent = null;",
      "",
      "\tpublic function set_state(component: $1StateComponent): $1StateComponent {",
      "\t\tfinal prev = this.state;",
      "\t\tthis.state = component;",
      "\t\tonComponentChanged(prev, this.state);",
      "\t\treturn this.state;",
      "\t}",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\toverride public function dispose() {",
      "\t\tsuper.dispose();",
      "\t\t__dispose__();",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tif (this._proxy != null) {",
      "\t\t\tthis._proxy.dispose();",
      "\t\t\tthis._proxy = null;",
      "\t\t}",
      "\t\tthis.logic = null;",
      "\t\tthis.render = null;",
      "\t\tthis.state = null;",
      "\t}",
      "",
      "\tpublic static function alloc(id: Int, factory: $1Factory): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.kind = EntityKind.$1;",
      "\t\tobject.factory = factory;",
      "\t\tobject.id = id;",
      "\t\tobject.typeId = factory.typeId;",
      "",
      "\t\tobject.logic = $1LogicComponent.alloc(factory);",
      "\t\tobject.render = $1RenderComponent.alloc(factory);",
      "\t\tobject.state = $1StateComponent.alloc(factory);",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ],
    "description": "Create engine2.Entity from template"
  },
  "ClassEntityFactory": {
    "prefix": ["classEntityFactory"],
    "body": [
      "package ${3:world}.rules.entities.factories;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends EntityFactory {",
      "\tpublic var conf: ${2:E}Conf;",
      "",
      "\tpublic function new(rules: Rules, conf: $2Conf) {",
      "\t\tsuper(conf.id, rules);",
      "\t\tthis.conf = conf;",
      "\t}",
      "",
      "\t// ---- Make / Save / Load ---- //",
      "\toverride public function make(id: Int, worldState: WorldState, conf: Dynamic = null): $2 {",
      "\t\tfinal entity = $2.alloc(id, this);",
      "\t\treturn entity;",
      "\t}",
      "}"
    ],
    "description": "Create a engine2.EntityFactory from template"
  },
  "ClassEntityConf": {
    "prefix": ["classEntityConf"],
    "body": [
      "package ${2:world}.rules.confs;",
      "",
      "typedef ${1:$TM_FILENAME_BASE} = {",
      "\tpublic var id: String;",
      "\tpublic var stringId: String;",
      "\tpublic var assetId: String;",
      "}"
    ]
  },
  "ClassEntityProxy": {
    "prefix": ["classEntityProxy"],
    "body": [
      "package ${4:world}.rules.proxies;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "",
      "class ${1:$TM_FILENAME_BASE} extends Proxy {",
      "",
      "\tvar ${3:object}: ${2:Object};",
      "",
      "\tfunction new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t\tthis.$3 = null;",
      "\t}",
      "",
      "\tpublic static function alloc(world: World, $3: $2): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.world = world;",
      "\t\tobject.$3 = $3;",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ]
  },
  "ClassContext": {
    "prefix": ["classContext"],
    "body": [
      "package ${2:world}.rules.contexts;",
      "",
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${1:$TM_FILENAME_BASE} extends Context {",
      "",
      "\tvar ${4:object}: ${3:Object} = null;",
      "",
      "\tfunction new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t\tthis.$4 = null;",
      "\t}",
      "",
      "\tpublic static function alloc(world: World, $4: $3): $1 {",
      "\t\tfinal ctx = $1.__alloc__();",
      "",
      "\t\tctx.world = world;",
      "\t\tctx.$4 = $4;",
      "",
      "\t\treturn ctx;",
      "\t}",
      "}"
    ]
  },
  "ClassRule": {
    "prefix": ["classRule"],
    "body": [
      "package ${2:world}.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\tpublic var id: String;",
      "}",
      "",
      "class $1 {",
      "",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic var id(get, never): String;",
      "",
      "\tpublic function get_id(): String {",
      "\t\treturn this.conf.id;",
      "\t}",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tthis.conf = conf;",
      "\t}",
      "}"
    ]
  },
  "varComponent": {
    "prefix": ["varcomponent"],
    "body": [
      "public var ${1:component}(default, set): ${2:Component} = null;",
      "",
      "public function set_$1(component: $2): $2 {",
      "\tfinal prev = this.$1;",
      "\tthis.$1 = component;",
      "\tonComponentChanged(prev, this.$1);",
      "\treturn this.$1;",
      "}"
    ]
  },
  "collectEntities": {
    "prefix": ["collectEntities"],
    "body": [
      "public function collectEntities(entities: Entities<Entity>) {",
      "}"
    ]
  },
  "collectEntities.Macro": {
    "prefix": ["macro.collectEntities"],
    "body": [
      "#if !macro @:build(zf.macros.Engine2.collectEntities()) #end"
    ]
  },
  "collectEntities.@collectEntity": {
    "prefix": ["@collectEntity"],
    "body": ["@collectEntity "]
  },

  "ClassState": {
    "prefix": ["classState"],
    "body": [
      "package ${2:world}.states;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends zf.sm.State {",
      "\tpublic static final Wait: String = \"$1.Wait\";",
      "",
      "\tpublic var world(default, null): World;",
      "",
      "\tpublic function new(world: World, name: String) {",
      "\t\tsuper(name);",
      "",
      "\t\tthis.world = world;",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tthis.world = null",
      "\t}",
      "",
      "\tpublic static function registerStates(stateManager: zf.sm.StateManager, world: World) {",
      "\t\tstateManager.registerState(new zf.sm.Wait($1.Wait));",
      "\t}",
      "}"
    ]
  },
  "ClassChildState": {
    "prefix": ["classChildState"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "private class ${1:Name}State extends $TM_FILENAME_BASE {",
      "",
      "\tfunction new() {",
      "\t\tsuper($TM_FILENAME_BASE.$1);",
      "\t}",
      "",
      "\toverride public function copy(): $1State {",
      "\t\treturn $1State.alloc(this.world);",
      "\t}",
      "",
      "\tpublic static function alloc(world: World): $1State {",
      "\t\tfinal state = $1State.__alloc__();",
      "",
      "\t\tstate.world = world;",
      "",
      "\t\treturn state;",
      "\t}",
      "}"
    ]
  },
  "state.update": {
    "prefix": ["state.update"],
    "body": [
      "override public function update(dt: Float) {",
      "\t$0",
      "}"
    ]
  },
  "state.getNextState": {
    "prefix": ["state.getNextState"],
    "body": [
      "override public function getNextState(): zf.sm.State {",
      "\t$0",
      "\treturn null;",
      "}"
    ]
  },
  "state.onStateEnterExit": {
    "prefix": ["state.onStateEnterExit"],
    "body": [
      "override public function onStateEnter() {}",
      "override public function onStateExit() {}"
    ]
  },

  "varsingleton": {
    "prefix": ["varsingleton"],
    "body": [
      "var _${1:item}: ${2:ItemType};",
      "public var $1(get, never): $2;",
      "",
      "public function get_$1(): $2 {",
      "\tif (this._$1 == null) this._$1 = new $2(${3:});",
      "\treturn this._$1;",
      "}"
    ]
  },

  "dispatcher.listen.old": {
    "prefix": ["mListen", "dispatcher.listen"],
    "body": [
      "${3:dispatcher}.listen($1.MessageType, (message: zf.Message) -> {",
      "\thandle$1(cast message);",
      "}, $2);"
    ],
    "description": ""
  },
  "messagesHandle.old": {
    "prefix": ["mHandle.old"],
    "body": [
      "function handle${1:Message}(m: $1) {",
      "\t//note: message will be dispose once this function exits.",
      "}"
    ]
  },
  "messagesHandle": {
    "prefix": ["handleMessage", "mHandle"],
    "body": [
      "@handleMessage(\"${1:Message}\", ${2:0})",
      "function m${3:handleMessage}(m: $1) {",
      "\t${4://note: message will be dispose once this function exits.}",
      "}"
    ]
  },

  "DispatcherDispatch": {
    "prefix": ["dispatch"],
    "body": [
      "${4:this.}dispatcher.dispatch(${1:Message}.alloc($2))${3:.dispose()};"
    ]
  },
  "mDispatcherDispatch": {
    "prefix": ["mDispatch"],
    "body": [
      "final m = ${4:this.}dispatcher.dispatch(${1:Message}.alloc($2));",
      "m.dispose();"
    ]
  },
  "messages.Macro": {
    "prefix": ["macro.messages"],
    "body": [
      "#if !macro @:build(zf.macros.Messages.build()) #end"
    ]
  },

  "ClassUIElement": {
    "prefix": ["classUIElement"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${1:$TM_FILENAME_BASE} extends UIElement {",
      "",
      "\tpublic var display: h2d.Object;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "",
      "\t\tinitCommon();",
      "\t}",
      "",
      "\tfunction initCommon() {",
      "\t\tthis.addChild(this.display = new h2d.Object());",
      "\t}",
      "",
      "\t/**",
      "\t\tReset the UIElement to a default state",
      "\t**/",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t\t// reset only the non-common object to make object pooling better",
      "\t}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.render();",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ],
    "description": "Create a empty UIElement"
  },

  "ClassUIElement.noPool": {
    "prefix": ["classUIElement.noPool"],
    "body": [
      "class ${1:$TM_FILENAME_BASE} extends UIElement {",
      "",
      "\tpublic var display: h2d.Object;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "",
      "\t\tinitCommon();",
      "\t}",
      "",
      "\tfunction initCommon() {",
      "\t\tthis.addChild(this.display = new h2d.Object());",
      "\t}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "}"
    ],
    "description": "Create a empty UIElement"
  },



  "DynamicTypeClassDefinition": {
    "prefix": ["classDynamicType"],
    "body": [
      "package world.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\tpublic var id: String;",
      "\tpublic var name: String;",
      "\tpublic var assetId: String;",
      "}",
      "",
      "/**",
      "\tDefine a type that is dynamically loaded from file",
      "**/",
      "class $1 implements Identifiable {",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic var id(get, never): String;",
      "",
      "\tfunction get_id() {",
      "\t\treturn conf.id;",
      "\t}",
      "",
      "\tpublic function identifier(): String {",
      "\treturn this.id;",
      "\t}",
      "",
      "\tpublic var name(get, never): String;",
      "",
      "\tfunction get_name() {",
      "\t\treturn conf.name;",
      "\t}",
      "",
      "\tpublic var assetId(get, never): String;",
      "",
      "\tfunction get_assetId() {",
      "\t\treturn conf.assetId;",
      "\t}",
      "",
      "\tpublic var displayName(get, never): String;",
      "",
      "\tpublic function get_displayName(): String {",
      "\t\treturn S.get('.${assetId}');",
      "\t}",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tthis.conf = conf;",
      "\t}",
      "}"
    ],
    "description": "Create a dynamic type"
  },
  "Rules.loadDynamicType": {
    "prefix": ["rules.loadDynamicTypes"],
    "body": [
      "/**",
      "\tThis loads into both Rules.${1:Type} as Dynamic and Rules.${2:types} as Map",
      "",
      "\tconfig.hs will requires the conf to be stored as $2.",
      "**/",
      "public final $1: Dynamic= {};",
      "public final $2: Map<String, $1> = [];",
      "function load$1(dir: String, filePath: String) {",
      "\tfinal t: DynamicAccess<Dynamic> = this.$1;",
      "\tfunction add(type: $1) {",
      "\t\tthis.$2[type.id] = type;",
      "\t\tt.set(type.name, type);",
      "\t\tLogger.debug('$1 Loaded: \\${type.name}.', '[Rules]');",
      "\t}",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1.$1Conf = t;",
      "\t\tfinal tt = new $1(conf);",
      "\t\tadd(tt);",
      "\t}",
      "}"
    ]
  },






  "Rules.loadEntity": {
    "prefix": ["rules.loadEntity"],
    "body": [
      "/**",
      "\tThis loads factories for ${1:Entity}.",
      "**/",
      "function load$1(dir: String, filePath: String) {",
      "\tfinal factories: Array<$1Factory> = [];",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal confs: Array<Dynamic> = executePath(configPath);",
      "",
      "\tfor (c in confs) {",
      "\t\tfinal conf: $1Conf = c;",
      "\t\tfinal factory = new $1Factory(this, conf);",
      "\t\tfactories.push(factory);",
      "\t}",
      "",
      "\tfor (factory in factories) registerEntity(factory);",
      "\tLogger.debug('\\${factories.length} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },
  "Rules.loadRule": {
    "prefix": ["rules.loadRule"],
    "body": [
      "/**",
      "\tThis load the ${1:RuleObject} to ${2:ruleObjects}",
      "**/",
      "public var $2: Map<String, $1> = [];",
      "function load$1(dir: String, filePath: String) {",
      "",
      "\tfunction add(type: $1) {",
      "\t\tthis.$2[type.id] = type;",
      "\t}",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tvar count = 0;",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1.$1Conf = t;",
      "\t\tfinal tt = new $1(conf);",
      "\t\tadd(tt);",
      "\t\tcount += 1;",
      "\t}",
      "\tLogger.debug('\\${count} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },




  "EnumAbstract": {
    "prefix": ["enumabstract"],
    "body": [
      "enum abstract ${1:$TM_FILENAME_BASE}(${2:String}) from $2 to $2 {",
      "}"
    ]
  },

  "TestWithoutWorld": {
    "prefix": ["classTestCase"],
    "body": [
      "package tests;",
      "",
      "/**",
      "\tA template for test cases without World object",
      "**/",
      "class ${1:$TM_FILENAME_BASE} extends TestCase {",
      "\tpublic static final Name = \"template\";",
      "",
      "\tpublic function new(testId: String) {",
      "\t\tsuper(testId, Name);",
      "\t}",
      "",
      "\toverride function setup() {",
      "\t\tsuper.setup();",
      "\t\tinitSteps();",
      "\t}",
      "",
      "\tfunction initSteps() {",
      "\t\trun(() -> {",
      "\t\t});",
      "\t}",
      "}"
    ],
    "description": "Test Template Without World"
  },
  "TestWithWorld": {
    "prefix": ["classWorldTestCase"],
    "body": [
      "package tests;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends WorldTestCase {",
      "\tpublic static final Name = \"$1\";",
      "",
      "\tpublic function new(testId: String) {",
      "\t\tsuper(testId, Name);",
      "\t}",
      "",
      "\toverride function setup() {",
      "\t\tsuper.setup();",
      "\t\tinitSteps();",
      "\t}",
      "",
      "\tfunction initSteps() {",
      "\t\trun(() -> {",
      "\t\t});",
      "\t}",
      "}"
    ],
    "description": "Test Template Without World"
  },
  "run": {
    "prefix": ["run"],
    "body": [
      "run(() -> {",
      "\tfinal state = this.world.worldState;",
      "\t${1}",
      "});"
    ],
    "description": "run with a state for test case"
  },

  "uiComponent": {
    "prefix": ["classUIComponent"],
    "body": [
      "class ${1:$TM_FILENAME_BASE}Component extends zf.ui.builder.Component {",
      "\tpublic function new() {",
      "\t\tsuper(\"${2:}\");",
      "\t}",
      "",
      "\toverride public function makeFromStruct(s: Dynamic, context: BuilderContext): h2d.Object {",
      "\t\treturn make(zf.Access.struct(s), context);",
      "\t}",
      "",
      "\toverride public function makeFromXML(element: Xml, context: BuilderContext): h2d.Object {",
      "\t\treturn make(zf.Access.xml(element), context);",
      "\t}",
      "",
      "\tfunction make(conf: zf.Access, context: BuilderContext): h2d.Object {",
      "\t\tfinal component = new $1();",
      "\t\treturn component;",
      "\t}",
      "}"
    ]
  },
  "zfEffect": {
    "prefix": ["classEffect"],
    "body": [
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\t> Effect.EffectConf,",
      "}",
      "",
      "class $1 extends Effect {",
      "",
      "\tvar object: h2d.Object;",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tsuper(conf);",
      "\t\tthis.conf = conf;",
      "\t\tdefaultConf(conf);",
      "\t\treset();",
      "\t}",
      "",
      "\tfunction defaultConf(conf: $1Conf) { }",
      "",
      "\toverride function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\toverride public function copy(): $1 {",
      "\t\treturn new $1(this.conf);",
      "\t}",
      "",
      "\toverride public function applyTo(object: h2d.Object, copy: Bool = false): Effect {",
      "\t\tfinal e = super.applyTo(object, copy);",
      "\t\tif (copy == true) return e;",
      "",
      "\t\tthis.object = object;",
      "\t\treturn this;",
      "\t}",
      "}"
    ]
  },

  "Serialisable": {
    "prefix": ["serialise"],
    "body": [
      "/**",
      "\tConvert to struct",
      "\t@return the struct representing the object",
      "**/",
      "public function toStruct(context: SerialiseContext): Dynamic {",
      "\tfinal sf: ${1:$TM_FILENAME_BASE}SF = {};",
      "\treturn sf;",
      "}",
      "",
      "/**",
      "\tLoad from struct.",
      "\t@return the object itself to allow for chaining",
      "**/",
      "public function loadStruct(context: SerialiseContext, data: Dynamic): $1 {",
      "\tfinal sf: ${1}SF = data;",
      "\treturn this;",
      "}"
    ]
  },
  "Serialisable.Macro": {
    "prefix": ["macro.serialise"],
    "body": [
      "#if !macro @:build(zf.macros.Serialise.build()) #end"
    ]
  },
  "Serialisable.SaveLoad": {
    "prefix": ["serialisable.saveload"],
    "body": [
      "// ---- Save / Load ----",
      "",
      "public function toStruct(context: SerialiseContext): Dynamic {",
      "\tfinal struct = __toStruct__(context, {});",
      "\treturn struct;",
      "}",
      "",
      "public function loadStruct(context: SerialiseContext, sf: Dynamic): ${1:$TM_FILENAME_BASE} {",
      "\t__loadStruct__(context, sf);",
      "\treturn this;",
      "}"
    ]
  },
  "Serialisable.@serialise": {
    "prefix": ["@serialise"],
    "body": ["@serialise "]
  },
  "Serialisable.@serialise.expand": {
    "prefix": ["@serialise.identifier"],
    "body": ["@serialise(null, true) "]
  },

  "ObjectPool.Macro": {
    "prefix": ["macro.objectPool"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.build()) #end"
    ]
  },
  "objectPoolalloc": {
    "prefix": ["objectPool.alloc"],
    "body": [
      "public static function ${2:alloc}(): ${1:$TM_FILENAME_BASE} {",
      "\tfinal object = $1.__alloc__();",
      "\treturn object;",
      "}"
    ]
  },

  "tooltipHelperSet": {
    "prefix": ["tooltipHelperSet"],
    "body": [
      "final window = new TooltipWindow();",
      "${1:object}.tooltipHelper = ${2:this.tooltipHelper};",
      "$1.tooltipWindow = window;",
      "$1.tooltipShowConf = { preferredDirection: [Right, Left, Up, Down] };"
    ]
  },
  "XmlComponent": {
    "prefix": ["classXmlComponent"],
    "body": [
      "#if !macro @:build(zf.macros.ObjectPool.addObjectPool()) #end",
      "class ${1:$TM_FILENAME_BASE} extends zf.ui.builder.XmlComponent {",
      "",
      "\tpublic function new() {",
      "\t\tsuper(\"ui/components/$1.xml\");",
      "",
      "\t\tinitComponent();",
      "\t}",
      "",
      "\t/**",
      "\t\tReset the UIElement to a default state",
      "\t**/",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\tpublic static function alloc(): $1 {",
      "\t\tfinal object = $1.__alloc__();",
      "",
      "\t\tobject.render();",
      "",
      "\t\treturn object;",
      "\t}",
      "}"
    ]
  },

  "init": {
    "prefix": ["init"],
    "body": [
      "public function init(world: zf.engine2.World) {",
      "\t${1:}",
      "}"
    ]
  }
}
