{
  "identifier": {
    "prefix": ["identifier"],
    "body": [
      "public function identifier(): String {",
      "\treturn ${1:this.id};",
      "}"
    ]
  },

  "ClassMessage": {
    "prefix": ["classMessage"],
    "body": [
      "package ${1:world}.messages;",
      "",
      "#if !macro",
      "@:build(zf.macros.ObjectPool.addObjectPool())",
      "#end",
      "class ${2:$TM_FILENAME_BASE} extends zf.Message {",
      "\tpublic static final MessageType = \"$2\";",
      "",
      "\tfunction new() {",
      "\t\tsuper(MessageType);",
      "\t}",
      "",
      "\tpublic function reset() {}",
      "",
      "\tpublic static function alloc(): ${2} {",
      "\t\tfinal m = __alloc__();",
      "\t\treturn m;",
      "\t}",
      "}"
    ],
    "description": "Create a message class from template."
  },

  "ClassSystem": {
    "prefix": ["classSystem"],
    "body": [
      "package ${1:world}.systems;",
      "",
      "class ${2:$TM_FILENAME_BASE} extends System {",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "\t}",
      "",
      "\toverride public function init(world: zf.engine2.World) {",
      "\t\tsuper.init(world);",
      "\t}",
      "}"
    ],
    "description": "Create a system class from template."
  },
  "Systems.functions": {
    "prefix": ["systems.functions"],
    "body": [
      "override public function onEvent(event: hxd.Event): Bool {",
      "\treturn false;",
      "}",
      "",
      "/**",
      "\treset the system to the same state after constructor",
      "**/",
      "override public function reset() {",
      "\tsuper.reset();",
      "}",
      "",
      "/**",
      "\tDispose the system data",
      "**/",
      "override public function dispose() {",
      "\tsuper.dispose();",
      "}",
      "",
      "/**",
      "\tupdate loop",
      "**/",
      "override public function update(dt: Float) {",
      "\tsuper.update(dt);",
      "}",
      "",
      "override public function onEntityAdded(entity: zf.engine2.Entity) {",
      "\tsuper.onEntityAdded(entity);",
      "\tfinal e: Entity = cast entity;",
      "}",
      "",
      "override public function onEntityRemoved(entity: zf.engine2.Entity) {",
      "\tsuper.onEntityRemoved(entity);",
      "\tfinal e: Entity = cast entity;",
      "}"
    ]
  },

  "ClassDataContainer": {
    "prefix": ["classDataContainer"],
    "body": [
      "package ${2:world}.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}SF = {",
      "}",
      "",
      "class $1 implements Serialisable {",
      "",
      "\t/**",
      "\t\tConvert to struct",
      "\t\t@return the struct representing the object",
      "\t**/",
      "\tpublic function toStruct(context: SerialiseContext): Dynamic {",
      "\t\tfinal sf: $1SF = {};",
      "\t\treturn sf;",
      "\t}",
      "",
      "\t/**",
      "\t\tLoad from struct.",
      "\t\t@return the object itself to allow for chaining",
      "\t**/",
      "\tpublic function loadStruct(context: SerialiseContext, data: Dynamic): $1 {",
      "\t\tfinal sf: $1SF = data;",
      "\t\treturn this;",
      "\t}",
      "}"
    ]
  },
  "ClassComponent": {
    "prefix": ["classStateComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}SF = {",
      "}",
      "",
      "class $1 extends Component implements Serialisable {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\tpublic var factory: ${2:Entity}Factory;",
      "",
      "\tpublic function new(factory: $2Factory) {",
      "\t\tthis.factory = factory;",
      "\t}",
      "",
      "\tpublic var ${3:entity}(get, never): $2;",
      "",
      "\tinline public function get_$3(): $2 {",
      "\t\treturn cast this.entity;",
      "\t}",
      "",
      "\tpublic function toStruct(context: SerialiseContext): Dynamic {",
      "\t\treturn {};",
      "\t}",
      "",
      "\tpublic function loadStruct(context: SerialiseContext, conf: Dynamic): Component {",
      "\t\tfinal sf: $1SF = cast conf;",
      "\t\treturn this;",
      "\t}",
      "}"
    ],
    "description": "Create a component class from template"
  },
  "ClassComponentNoSerialise": {
    "prefix": ["classComponent", "classLogicComponent", "classRenderComponent"],
    "body": [
      "package ${4:world}.rules.entities.components;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends Component {",
      "\tpublic static final ComponentType = \"$1\";",
      "",
      "\toverride public function get_typeId(): String {",
      "\t\treturn ComponentType;",
      "\t}",
      "",
      "\tpublic var factory: ${2:Entity}Factory;",
      "",
      "\tpublic var ${3:entity}(get, never): $2;",
      "",
      "\tinline public function get_$3(): $2 {",
      "\t\treturn cast this.entity;",
      "\t}",
      "",
      "\tpublic function new(factory: $2Factory) {",
      "\t\tthis.factory = factory;",
      "\t}",
      "",
      "}"
    ],
    "description": "Create a component class from template"
  },
  "Component.hlscript": {
    "prefix": ["component.hlscript"],
    "description": "Call a hlscript function for component",
    "body": [
      "public function ${1:Func}(ctx: ${2:Context}) {",
      "\tif (this.factory.conf.$1 == null) return;",
      "\treturn this.factory.conf.$1(ctx);",
      "}"
    ]
  },

  "ClassEntity": {
    "prefix": ["classEntity"],
    "body": [
      "package ${2:world}.rules.entities;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends Entity {",
      "",
      "\tvar _proxy: ${1:$TM_FILENAME_BASE}Proxy;",
      "",
      "\tpublic var proxy(get, never): $1Proxy;",
      "",
      "\tpublic function get_proxy(): $1Proxy {",
      "\t\tif (this._proxy == null) this._proxy = new $1Proxy(this.world, this);",
      "\t\treturn this._proxy;",
      "\t}",
      "",
      "\tpublic var logic(default, set): $1LogicComponent;",
      "",
      "\tpublic function set_logic(component: $1LogicComponent): $1LogicComponent {",
      "\t\tfinal prev = this.logic;",
      "\t\tthis.logic = component;",
      "\t\tonComponentChanged(prev, this.logic);",
      "\t\treturn this.logic;",
      "\t}",
      "",
      "\tpublic var render(default, set): $1RenderComponent;",
      "",
      "\tpublic function set_render(component: $1RenderComponent): $1RenderComponent {",
      "\t\tfinal prev = this.render;",
      "\t\tthis.render = component;",
      "\t\tonComponentChanged(prev, this.render);",
      "\t\treturn this.render;",
      "\t}",
      "",
      "\tpublic var state(default, set): $1StateComponent;",
      "",
      "\tpublic function set_state(component: $1StateComponent): $1StateComponent {",
      "\t\tfinal prev = this.state;",
      "\t\tthis.state = component;",
      "\t\tonComponentChanged(prev, this.state);",
      "\t\treturn this.state;",
      "\t}",
      "",
      "\tpublic function new(id: Int, factory: $1Factory) {",
      "\t\tsuper(id, factory);",
      "\t\tthis.kind = EntityKind.$1;",
      "\t\tthis.logic = new $1LogicComponent(factory);",
      "\t\tthis.render = new $1RenderComponent(factory);",
      "\t\tthis.state = new $1StateComponent(factory);",
      "\t}",
      "}"
    ],
    "description": "Create engine2.Entity from template"
  },
  "ClassEntityFactory": {
    "prefix": ["classEntityFactory"],
    "body": [
      "package ${3:world}.rules.entities.factories;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends EntityFactory {",
      "\tpublic var conf: ${2:E}Conf;",
      "",
      "\tpublic function new(rules: Rules, conf: $2Conf) {",
      "\t\tsuper(conf.id, rules);",
      "\t\tthis.conf = conf;",
      "\t}",
      "",
      "\t// ---- Make / Save / Load ---- //",
      "\toverride public function make(id: Int, worldState: WorldState, conf: Dynamic = null): Entity {",
      "\t\tfinal entity = new $2(id, this);",
      "\t\treturn entity;",
      "\t}",
      "}"
    ],
    "description": "Create a engine2.EntityFactory from template"
  },
  "ClassEntityConf": {
    "prefix": ["classEntityConf"],
    "body": [
      "package ${2:world}.rules.confs;",
      "",
      "typedef ${1:$TM_FILENAME_BASE} = {",
      "\tpublic var id: String;",
      "\tpublic var stringId: String;",
      "\tpublic var assetId: String;",
      "}"
    ]
  },
  "ClassEntityProxy": {
    "prefix": ["classEntityProxy"],
    "body": [
      "package ${4:world}.rules.proxies;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends Proxy {",
      "\tvar ${3:object}: ${2:Object};",
      "",
      "\tpublic function new(world: World, $3: $2) {",
      "\t\tsuper(world);",
      "\t\tthis.$3 = $3;",
      "\t}",
      "}"
    ]
  },
  "ClassUIElement": {
    "prefix": ["classUIElement"],
    "body": [
      "class ${1:$TM_FILENAME_BASE} extends UIElement {",
      "",
      "\tpublic var display: h2d.Object;",
      "",
      "\tpublic function new() {",
      "\t\tsuper();",
      "",
      "\t\tthis.addChild(this.display = new h2d.Object());",
      "\t\trender();",
      "\t}",
      "",
      "\t/**",
      "\t\tReset the UIElement to a default state",
      "\t**/",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\t/**",
      "\t\tRender the UIElement.",
      "",
      "\t\trender is only called once during uielement construction.",
      "\t**/",
      "\tfunction render() {}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "}"
    ],
    "description": "Create a empty UIElement"
  },
  "ClassContext": {
    "prefix": ["classContext"],
    "body": [
      "package ${2:world}.rules.contexts;",
      "",
      "#if !macro",
      "@:build(zf.macros.ObjectPool.addObjectPool())",
      "#end",
      "class ${1:$TM_FILENAME_BASE} extends Context {",
      "",
      "\tfunction new() {",
      "\t\tsuper(null);",
      "\t}",
      "",
      "\tpublic function reset() {",
      "\t\tthis.world = null",
      "\t}",
      "",
      "\tpublic static function alloc(world: World): $1 {",
      "\t\tfinal ctx = $1.__alloc__();",
      "",
      "\t\tctx.world = world;",
      "",
      "\t\treturn ctx;",
      "\t}",
      "}"
    ]
  },
  "ClassRule": {
    "prefix": ["classRule"],
    "body": [
      "package ${2:world}.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\tpublic var id: String;",
      "}",
      "",
      "class $1 {",
      "",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic var id(get, never): String;",
      "",
      "\tpublic function get_id(): String {",
      "\t\treturn this.conf.id;",
      "\t}",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tthis.conf = conf;",
      "\t}",
      "}"
    ]
  },

  "ClassState": {
    "prefix": ["classState"],
    "body": [
      "package ${2:world}.states;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends zf.sm.State {",
      "\tpublic static final Wait: String = \"$1.Wait\";",
      "",
      "\tpublic var world(default, null): World;",
      "",
      "\tpublic function new(world: World, name: String) {",
      "\t\tsuper(name);",
      "",
      "\t\tthis.world = world;",
      "\t}",
      "",
      "\toverride public function copy(): $1 {",
      "\t\tfinal state = new $1(this.world, this.name);",
      "\t\treturn state;",
      "\t}",
      "",
      "\tpublic static function registerStates(stateManager: zf.sm.StateManager, world: World) {",
      "\t\tstateManager.registerState(new zf.sm.Wait($1.Wait));",
      "\t}",
      "}"
    ]
  },
  "ClassChildState": {
    "prefix": ["classChildState"],
    "body": [
      "private class ${1:State} extends $TM_FILENAME_BASE {",
      "\tpublic function new(world: World) {",
      "\t\tsuper(world, $TM_FILENAME_BASE.$1);",
      "\t}",
      "",
      "\toverride public function copy(): $TM_FILENAME_BASE {",
      "\t\treturn new $1(this.world);",
      "\t}",
      "}"
    ]
  },
  "State.functions": {
    "prefix": ["state.functions"],
    "body": [
      "override public function update(dt: Float) {}",
      "override public function getNextState(): zf.sm.State {",
      "\treturn null;",
      "}",
      "override public function onStateEnter() {}",
      "override public function onStateExit() {}"
    ]
  },

  "varcomponent": {
    "prefix": ["varcomponent"],
    "body": [
      "public var ${1:component}(default, set): ${2:Component};",
      "",
      "public function set_$1(component: $2): $2 {",
      "\tfinal prev = this.$1;",
      "\tthis.$1 = component;",
      "\tonComponentChanged(prev, this.$1);",
      "\treturn this.$1;",
      "}"
    ],
    "description": "engine2 component variable"
  },
  "varsingleton": {
    "prefix": ["varsingleton"],
    "body": [
      "var _${1:item}: ${2:ItemType};",
      "public var $1(get, never): $2;",
      "",
      "public function get_$1(): $2 {",
      "\tif (this._$1 == null) this._$1 = new $2(${3:});",
      "\treturn this._$1;",
      "}"
    ]
  },
  "varproxy": {
    "prefix": ["varproxy"],
    "body": [
      "var _proxy: ${1:$TM_FILENAME_BASE}Proxy;",
      "",
      "public var proxy(get, never): $1Proxy;",
      "",
      "public function get_proxy(): $1Proxy {",
      "\tif (this._proxy == null) this._proxy = new $1Proxy(this.world, this);",
      "\treturn this._proxy;",
      "}"
    ]
  },

  "dispatcher.listen": {
    "prefix": ["mListen", "dispatcher.listen"],
    "body": [
      "${3:dispatcher}.listen($1.MessageType, (message: zf.Message) -> {",
      "\thandle$1(cast message);",
      "}, $2);"
    ],
    "description": ""
  },
  "ListenMessageFunction": {
    "prefix": ["mHandle", "handleFunc"],
    "body": [
      "function handle${1:Message}(m: $1) {",
      "}"
    ]
  },
  "DispatcherDispatch": {
    "prefix": ["dispatch"],
    "body": [
      "${4:this.}dispatcher.dispatch(${1:Message}.alloc($2))${3:.dispose()};"
    ]
  },
  "mDispatcherDispatch": {
    "prefix": ["mDispatch"],
    "body": [
      "final m = ${4:this.}dispatcher.dispatch(${1:Message}.alloc($2));",
      "m.dispose();"
    ]
  },




  "DynamicTypeClassDefinition": {
    "prefix": ["classDynamicType"],
    "body": [
      "package world.rules;",
      "",
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\tpublic var id: String;",
      "\tpublic var name: String;",
      "\tpublic var assetId: String;",
      "}",
      "",
      "/**",
      "\tDefine a type that is dynamically loaded from file",
      "**/",
      "class $1 {",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic var id(get, never): String;",
      "",
      "\tfunction get_id() {",
      "\t\treturn conf.id;",
      "\t}",
      "",
      "\tpublic var name(get, never): String;",
      "",
      "\tfunction get_name() {",
      "\t\treturn conf.name;",
      "\t}",
      "",
      "\tpublic var assetId(get, never): String;",
      "",
      "\tfunction get_assetId() {",
      "\t\treturn conf.assetId;",
      "\t}",
      "",
      "\tpublic var displayName(get, never): String;",
      "",
      "\tpublic function get_displayName(): String {",
      "\t\treturn S.get('.${assetId}');",
      "\t}",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tthis.conf = conf;",
      "\t}",
      "}"
    ],
    "description": "Create a dynamic type"
  },
  "Rules.loadDynamicType": {
    "prefix": ["rules.loadDynamicTypes"],
    "body": [
      "/**",
      "\tThis loads into both Rules.${1:Type} as Dynamic and Rules.${2:types} as Map",
      "",
      "\tconfig.hs will requires the conf to be stored as $2.",
      "**/",
      "public final $1: Dynamic= {};",
      "public final $2: Map<String, $1> = [];",
      "function load$1(dir: String, filePath: String) {",
      "\tfinal t: DynamicAccess<Dynamic> = this.$1;",
      "\tfunction add(type: $1) {",
      "\t\tthis.$2[type.id] = type;",
      "\t\tt.set(type.name, type);",
      "\t\tLogger.debug('$1 Loaded: \\${type.name}.', '[Rules]');",
      "\t}",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1.$1Conf = t;",
      "\t\tfinal tt = new $1(conf);",
      "\t\tadd(tt);",
      "\t}",
      "}"
    ]
  },






  "Rules.loadEntity": {
    "prefix": ["rules.loadEntity"],
    "body": [
      "/**",
      "\tThis loads factories for ${1:Entity}.",
      "**/",
      "function load$1(dir: String, filePath: String) {",
      "\tfinal factories: Array<$1Factory> = [];",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal confs: Array<Dynamic> = executePath(configPath);",
      "",
      "\tfor (c in confs) {",
      "\t\tfinal conf: $1Conf = c;",
      "\t\tfinal factory = new $1Factory(this, conf);",
      "\t\tfactories.push(factory);",
      "\t}",
      "",
      "\tfor (factory in factories) registerEntity(factory);",
      "\tLogger.debug('\\${factories.length} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },
  "Rules.loadRule": {
    "prefix": ["rules.loadRule"],
    "body": [
      "/**",
      "\tThis load the ${1:RuleObject} to ${2:ruleObjects}",
      "**/",
      "public var $2: Map<String, $1> = [];",
      "function load$1(dir: String, filePath: String) {",
      "",
      "\tfunction add(type: $1) {",
      "\t\tthis.$2[type.id] = type;",
      "\t}",
      "",
      "\tfinal configPath = haxe.io.Path.join([dir, filePath]);",
      "\tfinal data: Array<Dynamic> = executePath(configPath);",
      "",
      "\tvar count = 0;",
      "\tfor (t in data) {",
      "\t\tfinal conf: $1.$1Conf = t;",
      "\t\tfinal tt = new $1(conf);",
      "\t\tadd(tt);",
      "\t\tcount += 1;",
      "\t}",
      "\tLogger.debug('\\${count} $1s loaded.', \"[Rules]\");",
      "}"
    ]
  },




  "EnumAbstract": {
    "prefix": ["enumabstract"],
    "body": [
      "enum abstract ${1:$TM_FILENAME_BASE}(${2:String}) from $2 to $2 {",
      "}"
    ]
  },

  "TestWithoutWorld": {
    "prefix": ["classTestCase"],
    "body": [
      "package tests;",
      "",
      "/**",
      "\tA template for test cases without World object",
      "**/",
      "class ${1:$TM_FILENAME_BASE} extends TestCase {",
      "\tpublic static final Name = \"template\";",
      "",
      "\tpublic function new(testId: String) {",
      "\t\tsuper(testId, Name);",
      "\t}",
      "",
      "\toverride function setup() {",
      "\t\tsuper.setup();",
      "\t\tinitSteps();",
      "\t}",
      "",
      "\tfunction initSteps() {",
      "\t\trun(() -> {",
      "\t\t});",
      "\t}",
      "}"
    ],
    "description": "Test Template Without World"
  },
  "TestWithWorld": {
    "prefix": ["classWorldTestCase"],
    "body": [
      "package tests;",
      "",
      "class ${1:$TM_FILENAME_BASE} extends WorldTestCase {",
      "\tpublic static final Name = \"$1\";",
      "",
      "\tpublic function new(testId: String) {",
      "\t\tsuper(testId, Name);",
      "\t}",
      "",
      "\toverride function setup() {",
      "\t\tsuper.setup();",
      "\t\tinitSteps();",
      "\t}",
      "",
      "\tfunction initSteps() {",
      "\t\trun(() -> {",
      "\t\t});",
      "\t}",
      "}"
    ],
    "description": "Test Template Without World"
  },
  "run": {
    "prefix": ["run"],
    "body": [
      "run(() -> {",
      "\tfinal state = this.world.worldState;",
      "\t${1}",
      "});"
    ],
    "description": "run with a state for test case"
  },

  "uiComponent": {
    "prefix": ["classUIComponent"],
    "body": [
      "class ${1:$TM_FILENAME_BASE}Component extends zf.ui.builder.Component {",
      "\tpublic function new() {",
      "\t\tsuper(\"${2:}\");",
      "\t}",
      "",
      "\toverride public function makeFromStruct(s: Dynamic, context: BuilderContext): h2d.Object {",
      "\t\treturn make(zf.Access.struct(s), context);",
      "\t}",
      "",
      "\toverride public function makeFromXML(element: Xml, context: BuilderContext): h2d.Object {",
      "\t\treturn make(zf.Access.xml(element), context);",
      "\t}",
      "",
      "\tfunction make(conf: zf.Access, context: BuilderContext): h2d.Object {",
      "\t\tfinal component = new $1();",
      "\t\treturn component;",
      "\t}",
      "}"
    ]
  },
  "zfEffect": {
    "prefix": ["classEffect"],
    "body": [
      "typedef ${1:$TM_FILENAME_BASE}Conf = {",
      "\t> Effect.EffectConf,",
      "}",
      "",
      "class $1 extends Effect {",
      "",
      "\tvar object: h2d.Object;",
      "\tvar conf: $1Conf;",
      "",
      "\tpublic function new(conf: $1Conf) {",
      "\t\tsuper(conf);",
      "\t\tthis.conf = conf;",
      "\t\tdefaultConf(conf);",
      "\t\treset();",
      "\t}",
      "",
      "\tfunction defaultConf(conf: $1Conf) { }",
      "",
      "\toverride function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\toverride public function copy(): $1 {",
      "\t\treturn new $1(this.conf);",
      "\t}",
      "",
      "\toverride public function applyTo(object: h2d.Object, copy: Bool = false): Effect {",
      "\t\tfinal e = super.applyTo(object, copy);",
      "\t\tif (copy == true) return e;",
      "",
      "\t\tthis.object = object;",
      "\t\treturn this;",
      "\t}",
      "}"
    ]
  },

  "Serialisable": {
    "prefix": ["serialise"],
    "body": [
      "/**",
      "\tConvert to struct",
      "\t@return the struct representing the object",
      "**/",
      "public function toStruct(context: SerialiseContext): Dynamic {",
      "\tfinal sf: ${1:$TM_FILENAME_BASE}SF = {};",
      "\treturn sf;",
      "}",
      "",
      "/**",
      "\tLoad from struct.",
      "\t@return the object itself to allow for chaining",
      "**/",
      "public function loadStruct(context: SerialiseContext, data: Dynamic): $1 {",
      "\tfinal sf: ${1}SF = data;",
      "\treturn this;",
      "}"
    ]
  },
  "objectPoolmacro": {
    "prefix": ["objectPool.macro"],
    "body": [
      "#if !macro",
      "@:build(zf.macros.ObjectPool.addObjectPool())",
      "#end"
    ]
  },
  "objectPoolalloc": {
    "prefix": ["objectPool.alloc"],
    "body": [
      "public static function ${2:alloc}(): ${1:$TM_FILENAME_BASE} {",
      "\tfinal object = $1.__alloc__();",
      "\treturn object;",
      "}"
    ]
  },

  "tooltipHelperSet": {
    "prefix": ["tooltipHelperSet"],
    "body": [
      "final window = new TooltipWindow();",
      "${1:object}.tooltipHelper = ${2:this.tooltipHelper};",
      "$1.tooltipWindow = window;",
      "$1.tooltipShowConf = { preferredDirection: [Right, Left, Up, Down] };"
    ]
  },
  "XmlComponent": {
    "prefix": ["classXmlComponent"],
    "body": [
      "class ${1:$TM_FILENAME_BASE} extends zf.ui.builder.XmlComponent {",
      "",
      "\tpublic function new() {",
      "\t\tsuper(\"ui/components/$1.xml\");",
      "",
      "\t\tinitComponent();",
      "\t}",
      "",
      "\t/**",
      "\t\tReset the UIElement to a default state",
      "\t**/",
      "\toverride public function reset() {",
      "\t\tsuper.reset();",
      "\t}",
      "",
      "\t/**",
      "\t\tRefresh the uielement state",
      "",
      "\t\trefresh can be called multiple times to update the state",
      "\t**/",
      "\tpublic function refresh() {}",
      "}"
    ]
  },


  "init": {
    "prefix": ["init"],
    "body": [
      "public function init(world: zf.engine2.World) {",
      "\t${1:}",
      "}"
    ]
  }
}
